//-------------------------------------------------------------------
// REFSPR.C
//-------------------------------------------------------------------

#include "refresh.h"
#include <string.h>

// Sprite info generated by SRPGRAB

#include "sprstruc.c"

ushort	numvisspr;


//===================================================================
//								MERGESORT ROUTINES
//===================================================================

void Merge (void);


//-------------------------------------------------------------------
// Merge			Merges src1/size1 and src2/size2 to dest
//-------------------------------------------------------------------

#ifndef __ORCAC__

void Merge (void)
{

//----------------------------------
// Merge two parts of the unsorted
// array to the sorted array
//----------------------------------

	if (*src1 > *src2)
		goto mergefrom2;
	
mergefrom1:
	*dest++ = *src1++;
	if (!--size1)
		goto finishfrom2;
	if (*src1 < *src2)
		goto mergefrom1;
	
mergefrom2:
	*dest++ = *src2++;
	if (!--size2)
		goto finishfrom1;
	if (*src1 < *src2)
		goto mergefrom1;	
	goto mergefrom2;

finishfrom2:
	while (size2--)
		*dest++ = *src2++;
	return;

finishfrom1:
	while (size1--)
		*dest++ = *src1++;
}

#endif


//-------------------------------------------------------------------
// SortEvents		Sorts the events from xevents[0] to xevent_p
//						firstevent will be set to the first sorted event
//						(either xevents[0] or sortbuffer[0]) lastevent will
//						be set to one past the last sorted event
//-------------------------------------------------------------------

void SortEvents (void)
{
	ushort 	count, blockpairs;
	ushort	size;
	ushort	sort;
	ushort	remaining;
	ushort	*sorted,*unsorted,*temp;
    

	count = xevent_p - xevents;
	if (count<2)
	{
		firstevent = xevents;
		lastevent = xevents+count;
		return;
	}
	
	size = 1;	// Source size		(<<1 / loop)
	sort = 1;	// Iteration number (+1 / loop)
	
	sorted = xevents;
	unsorted = sortbuffer;
	
	do
	{
		blockpairs = count>>sort;
		
	//----------------------------------
	// Pointers incremented by the merge
	//----------------------------------

		src1 = sorted;
		src2 = sorted + (blockpairs <<  (sort-1));
		dest = unsorted;
		
	//----------------------------------
	// Merge paired blocks
	//----------------------------------

		while (blockpairs--)
		{
			size1 = size2 = size;
			Merge ();
		}
		
	//----------------------------------
	// Copy or merge the leftovers
	//----------------------------------

		remaining = count&((size<<1)-1);
		if (remaining > size)
		{	// One complete block and one fragment
			src1 = src2 + size;
			size1 =  remaining - size;
			size2 = size;
			Merge ();
		}
		else if (remaining>0)
		{	// Just a single sorted fragment
			while (remaining--)
				*dest++ = *src2++;
		}
		
	//----------------------------------
	// Get ready to sort back to the
	// other array
	//----------------------------------

		size <<= 1;
		if ( size >= count)
		{
			firstevent = unsorted;
			lastevent = unsorted+count;
			return;
		}
		
		sort++;
		temp = sorted;
		sorted = unsorted;
		unsorted = temp;

#if 0
		{
			int i;
			for (i=0;i<count;i++)
				printf ("%i  ",arrays[sort][i]);
			printf ("\n\n");
		}
#endif

	} while (1);
}


//===================================================================
//							SPRITE DRAWING
//===================================================================


//-------------------------------------------------------------------
// RenderSprite		CALLED: CORE ROUTINE
//-------------------------------------------------------------------

extern 	short 			rs_x1, rs_x2;
extern	vissprite_t 	*rs_vseg;
void RenderSprite (void);

#ifndef __ORCAC__
short 		rs_x1, rs_x2;
vissprite_t 	*rs_vseg;

void RenderSprite (void)
{
	int			x;
	int			texturecolumn;
	int			column;
	int			scaler;
		
	scaler = rs_vseg->clipscale>>FRACBITS;

	column = 0;
	if (rs_x1 > rs_vseg->x1)
		column += (rs_x1-rs_vseg->x1)*rs_vseg->columnstep;
		
//----------------------------------
// Calculate and draw each collumn
//----------------------------------

	for (x=rs_x1 ; x <= rs_x2 ; x++, column += rs_vseg->columnstep)
	{
		if (xscale[x] > rs_vseg->clipscale)
			continue;	// Obscured by a wall
		texturecolumn = column>>FRACBITS;
		IO_ScaleMaskedColumn (x,scaler, rs_vseg->pos, texturecolumn);
	}
}
#endif


//-------------------------------------------------------------------
// AddSprite		CALLED: ~10 / frame
//-------------------------------------------------------------------

boolean missilesprite;

void AddSprite (thing_t *thing, ushort actornum);

#ifndef __ORCAC__
void AddSprite (thing_t *thing, ushort actornum)
{
	fixed_t		tx,tz;
	ufixed_t		scale;
	int			px;
	sprite_t		*patch;
	int			x1, x2;
	ushort		width, zslope;
		
//----------------------------------
// Transform the origin point
//----------------------------------

	trx = thing->x - viewx;
	try = viewy - thing->y;
	tz = R_TransformZ ();

	if (tz < MINZ)
		return;
		
	if (tz>=MAXZ)
		tz = MAXZ-1;
	scale = scaleatzptr[tz];

	tx = R_TransformX ();
	zslope = tz + (tz>>1);
	if ( (tx > 0 && (ushort)tx> zslope) || (tx<0 && (ushort)-tx>zslope) )
		return;		// Off the sides

	px = CENTERX + (SUFixedMul (tx,scale)>>7);

//----------------------------------
// Calculate edges of the shape
//----------------------------------

	patch = &sprites[thing->sprite];
		
	width = UFixedMul (patch->width,scale)>>5; 	// OPTIMIZE
	if (!width)
		return;		// Too far away
	x1 = px - (short)(width>>1);
	if (x1 >= SCREENWIDTH)
		return;		// Off the right side
	x2 = x1 + width - 1;
	if (x2 < 0)
		return;		// Off the left side

	visspr_p->pos = patch->pos;
	visspr_p->x1 = x1;
	visspr_p->x2 = x2;
	visspr_p->clipscale = scale;
	visspr_p->columnstep =  UDiv16by8 (patch->width<<8, width);
	visspr_p->actornum = actornum;

//----------------------------------
// Pack the vissprite number into
// the low 6 bits of the scale for
// sorting
//----------------------------------

	*xevent_p++ = (scale&~(MAXVISSPRITES-1)) |  numvisspr;

	visspr_p++;
	numvisspr ++;
}
#endif


//-------------------------------------------------------------------
// DrawTopSprite		Draw a scaling game over sprite on top of
//							everything
//-------------------------------------------------------------------

ushort	topspritescale = 0;
ushort	topspritenum = 0;

void DrawTopSprite (void)
{
	sprite_t		*patch;
	int			x1, x2;
	ushort		width;

	if (!topspritescale)
		return;

//-------------------------------
// Calculate edges of the shape
//-------------------------------

	patch = &sprites[topspritenum];
		
	width = UFixedMul (patch->width, topspritescale)>>5; 
	if (!width)
		return;		// Too far away
	x1 = CENTERX - (short)(width>>1);
	if (x1 >= SCREENWIDTH)
		return;		// Off the rigth side
	x2 = x1 + width - 1;
	if (x2 < 0)
		return;		// Off the left side

	visspr_p->pos = patch->pos;
	visspr_p->x1 = x1;
	visspr_p->x2 = x2;
	visspr_p->clipscale = topspritescale;
	visspr_p->columnstep =  UDiv16by8 (patch->width<<8, x2-x1+1);

//-------------------------------
// Pack the vissprite number into
// the low 6 bits of the scale
// for sorting.  Make sure it is
// sorted to be drawn last
//-------------------------------

	memset (xscale,0,sizeof(xscale));	// Don't clip behind anything
	if (x1<0)
		x1 = 0;
	if (x2>=SCREENWIDTH)
		x2 = SCREENWIDTH-1;
	rs_x1 = x1;
	rs_x2 = x2;
	rs_vseg = visspr_p;
	RenderSprite ();
}


//-------------------------------------------------------------------
// DrawSprites		CALLED: 1 / frame
//-------------------------------------------------------------------

void DrawSprites (void);

#ifndef __ORCAC__
void DrawSprites (void)
{
	vissprite_t	*dseg;
	int			x1,x2;
	int			i;
	static_t		*stat;
	actor_t		*jactor;
	ushort		*xe;
	
//-------------------------------------------
// OPTIMIZE: do this with a linked list/area
//-------------------------------------------

	visspr_p = vissprites;	// No sprites in view yet
	numvisspr = 0;

//-------------------------------------------	
// xevents are now used as depth events
//-------------------------------------------	

	xevent_p = xevents;
	
//-------------------------------------------	
// Add all sprites in visareas
//-------------------------------------------	

	missilesprite = false;
	for (i=0,stat = statics; i<numstatics; i++,stat++)
		if (areavis[stat->areanumber])
			AddSprite ((thing_t *)stat, 0);
	
	for (i=1,jactor = actors+1; i<numactors; i++,jactor++)
		if (areavis[jactor->areanumber])
			AddSprite ((thing_t *)jactor, i);
	
	missilesprite = true;
	for (i=0,missile = missiles; i<nummissiles; i++,missile++)
		if (areavis[missile->areanumber])
			AddSprite ((thing_t *)missile,0);

//-------------------------------------------	
// Sort sprites from back to front
//-------------------------------------------	

	SortEvents ();

//-------------------------------------------	
// Draw from smallest scale to largest
//-------------------------------------------	

	for (xe=firstevent; xe < lastevent; xe++)
	{
		dseg = vissprites + (*xe&(MAXVISSPRITES-1));

		x1 = dseg->x1;
		if (x1<0)
			x1 = 0;
		x2 = dseg->x2;
		if (x2>=SCREENWIDTH)
			x2 = SCREENWIDTH-1;
		rs_x1 = x1;
		rs_x2 = x2;
		rs_vseg = dseg;
		RenderSprite ();
	}
	
}
#endif


